//go:build !ignore_autogenerated

/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

func (in *Backup) DeepCopyInto(out *Backup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *Backup) DeepCopy() *Backup {
	if in == nil {
		return nil
	}
	out := new(Backup)
	in.DeepCopyInto(out)
	return out
}

func (in *Backup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *BackupList) DeepCopyInto(out *BackupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]Backup, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *BackupList) DeepCopy() *BackupList {
	if in == nil {
		return nil
	}
	out := new(BackupList)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *BackupSpec) DeepCopyInto(out *BackupSpec) {
	*out = *in
	if in.StorageRef != nil {
		out.StorageRef = new(corev1.LocalObjectReference)
		*out.StorageRef = *in.StorageRef
	}
	if in.Export != nil {
		out.Export = new(ExportSpec)
		in.Export.DeepCopyInto(out.Export)
	}
	if in.Snapshot != nil {
		out.Snapshot = new(SnapshotSpec)
		in.Snapshot.DeepCopyInto(out.Snapshot)
	}
	if in.Resources != nil {
		out.Resources = new(ResourceSelector)
		in.Resources.DeepCopyInto(out.Resources)
	}
	if in.Timeout != nil {
		out.Timeout = new(metav1.Duration)
		*out.Timeout = *in.Timeout
	}
	if in.TTL != nil {
		out.TTL = new(metav1.Duration)
		*out.TTL = *in.TTL
	}
	if in.RetainUntil != nil {
		out.RetainUntil = new(metav1.Time)
		*out.RetainUntil = *in.RetainUntil
	}
}

func (in *BackupSpec) DeepCopy() *BackupSpec {
	if in == nil {
		return nil
	}
	out := new(BackupSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupStatus) DeepCopyInto(out *BackupStatus) {
	*out = *in
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		copy(out.Conditions, in.Conditions)
	}
	if in.StartedAt != nil {
		out.StartedAt = new(metav1.Time)
		*out.StartedAt = *in.StartedAt
	}
	if in.CompletedAt != nil {
		out.CompletedAt = new(metav1.Time)
		*out.CompletedAt = *in.CompletedAt
	}
}

func (in *BackupStatus) DeepCopy() *BackupStatus {
	if in == nil {
		return nil
	}
	out := new(BackupStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupStorageLocation) DeepCopyInto(out *BackupStorageLocation) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *BackupStorageLocation) DeepCopy() *BackupStorageLocation {
	if in == nil {
		return nil
	}
	out := new(BackupStorageLocation)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupStorageLocation) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *BackupStorageLocationList) DeepCopyInto(out *BackupStorageLocationList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]BackupStorageLocation, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *BackupStorageLocationList) DeepCopy() *BackupStorageLocationList {
	if in == nil {
		return nil
	}
	out := new(BackupStorageLocationList)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupStorageLocationList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *BackupStorageLocationSpec) DeepCopyInto(out *BackupStorageLocationSpec) {
	*out = *in
	if in.S3 != nil {
		out.S3 = new(S3LocationSpec)
		in.S3.DeepCopyInto(out.S3)
	}
	if in.NFS != nil {
		out.NFS = new(NFSLocationSpec)
		in.NFS.DeepCopyInto(out.NFS)
	}
}

func (in *BackupStorageLocationSpec) DeepCopy() *BackupStorageLocationSpec {
	if in == nil {
		return nil
	}
	out := new(BackupStorageLocationSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *BackupStorageLocationStatus) DeepCopyInto(out *BackupStorageLocationStatus) {
	*out = *in
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		copy(out.Conditions, in.Conditions)
	}
	if in.LastValidated != nil {
		out.LastValidated = new(metav1.Time)
		*out.LastValidated = *in.LastValidated
	}
}

func (in *BackupStorageLocationStatus) DeepCopy() *BackupStorageLocationStatus {
	if in == nil {
		return nil
	}
	out := new(BackupStorageLocationStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterBackup) DeepCopyInto(out *ClusterBackup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ClusterBackup) DeepCopy() *ClusterBackup {
	if in == nil {
		return nil
	}
	out := new(ClusterBackup)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterBackup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClusterBackupList) DeepCopyInto(out *ClusterBackupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ClusterBackup, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ClusterBackupList) DeepCopy() *ClusterBackupList {
	if in == nil {
		return nil
	}
	out := new(ClusterBackupList)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterBackupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClusterBackupSpec) DeepCopyInto(out *ClusterBackupSpec) {
	*out = *in
	in.BackupSpec.DeepCopyInto(&out.BackupSpec)
	if in.Namespaces != nil {
		out.Namespaces = new(NamespaceSelector)
		in.Namespaces.DeepCopyInto(out.Namespaces)
	}
	if in.IncludeClusterResources != nil {
		out.IncludeClusterResources = new(bool)
		*out.IncludeClusterResources = *in.IncludeClusterResources
	}
}

func (in *ClusterBackupSpec) DeepCopy() *ClusterBackupSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterBackupSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterBackupStatus) DeepCopyInto(out *ClusterBackupStatus) {
	*out = *in
	in.BackupStatus.DeepCopyInto(&out.BackupStatus)
}

func (in *ClusterBackupStatus) DeepCopy() *ClusterBackupStatus {
	if in == nil {
		return nil
	}
	out := new(ClusterBackupStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterRestore) DeepCopyInto(out *ClusterRestore) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ClusterRestore) DeepCopy() *ClusterRestore {
	if in == nil {
		return nil
	}
	out := new(ClusterRestore)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterRestore) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClusterRestoreList) DeepCopyInto(out *ClusterRestoreList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]ClusterRestore, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *ClusterRestoreList) DeepCopy() *ClusterRestoreList {
	if in == nil {
		return nil
	}
	out := new(ClusterRestoreList)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterRestoreList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClusterRestoreSpec) DeepCopyInto(out *ClusterRestoreSpec) {
	*out = *in
	in.RestoreSpec.DeepCopyInto(&out.RestoreSpec)
}

func (in *ClusterRestoreSpec) DeepCopy() *ClusterRestoreSpec {
	if in == nil {
		return nil
	}
	out := new(ClusterRestoreSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ClusterRestoreStatus) DeepCopyInto(out *ClusterRestoreStatus) {
	*out = *in
	in.RestoreStatus.DeepCopyInto(&out.RestoreStatus)
}

func (in *ClusterRestoreStatus) DeepCopy() *ClusterRestoreStatus {
	if in == nil {
		return nil
	}
	out := new(ClusterRestoreStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ExportSpec) DeepCopyInto(out *ExportSpec) {
	*out = *in
	if in.Enabled != nil {
		out.Enabled = new(bool)
		*out.Enabled = *in.Enabled
	}
}

func (in *ExportSpec) DeepCopy() *ExportSpec {
	if in == nil {
		return nil
	}
	out := new(ExportSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *NamespaceSelector) DeepCopyInto(out *NamespaceSelector) {
	*out = *in
	if in.Included != nil {
		out.Included = make([]string, len(in.Included))
		copy(out.Included, in.Included)
	}
	if in.Excluded != nil {
		out.Excluded = make([]string, len(in.Excluded))
		copy(out.Excluded, in.Excluded)
	}
}

func (in *NamespaceSelector) DeepCopy() *NamespaceSelector {
	if in == nil {
		return nil
	}
	out := new(NamespaceSelector)
	in.DeepCopyInto(out)
	return out
}

func (in *NFSLocationSpec) DeepCopyInto(out *NFSLocationSpec) {
	*out = *in
	if in.PVCRef != nil {
		out.PVCRef = new(corev1.LocalObjectReference)
		*out.PVCRef = *in.PVCRef
	}
	if in.MountOptions != nil {
		out.MountOptions = make([]string, len(in.MountOptions))
		copy(out.MountOptions, in.MountOptions)
	}
	if in.CredentialsSecretRef != nil {
		out.CredentialsSecretRef = new(corev1.SecretReference)
		*out.CredentialsSecretRef = *in.CredentialsSecretRef
	}
}

func (in *NFSLocationSpec) DeepCopy() *NFSLocationSpec {
	if in == nil {
		return nil
	}
	out := new(NFSLocationSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *RemoteCluster) DeepCopyInto(out *RemoteCluster) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *RemoteCluster) DeepCopy() *RemoteCluster {
	if in == nil {
		return nil
	}
	out := new(RemoteCluster)
	in.DeepCopyInto(out)
	return out
}

func (in *RemoteCluster) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *RemoteClusterAuth) DeepCopyInto(out *RemoteClusterAuth) {
	*out = *in
}

func (in *RemoteClusterAuth) DeepCopy() *RemoteClusterAuth {
	if in == nil {
		return nil
	}
	out := new(RemoteClusterAuth)
	in.DeepCopyInto(out)
	return out
}

func (in *RemoteClusterList) DeepCopyInto(out *RemoteClusterList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]RemoteCluster, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *RemoteClusterList) DeepCopy() *RemoteClusterList {
	if in == nil {
		return nil
	}
	out := new(RemoteClusterList)
	in.DeepCopyInto(out)
	return out
}

func (in *RemoteClusterList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *RemoteClusterSpec) DeepCopyInto(out *RemoteClusterSpec) {
	*out = *in
	in.Auth.DeepCopyInto(&out.Auth)
	if in.CABundle != nil {
		out.CABundle = make([]byte, len(in.CABundle))
		copy(out.CABundle, in.CABundle)
	}
}

func (in *RemoteClusterSpec) DeepCopy() *RemoteClusterSpec {
	if in == nil {
		return nil
	}
	out := new(RemoteClusterSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *RemoteClusterStatus) DeepCopyInto(out *RemoteClusterStatus) {
	*out = *in
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		copy(out.Conditions, in.Conditions)
	}
	if in.LastValidated != nil {
		out.LastValidated = new(metav1.Time)
		*out.LastValidated = *in.LastValidated
	}
}

func (in *RemoteClusterStatus) DeepCopy() *RemoteClusterStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteClusterStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ResourceSelector) DeepCopyInto(out *ResourceSelector) {
	*out = *in
	if in.IncludedResources != nil {
		out.IncludedResources = make([]string, len(in.IncludedResources))
		copy(out.IncludedResources, in.IncludedResources)
	}
	if in.ExcludedResources != nil {
		out.ExcludedResources = make([]string, len(in.ExcludedResources))
		copy(out.ExcludedResources, in.ExcludedResources)
	}
	if in.LabelSelector != nil {
		out.LabelSelector = new(metav1.LabelSelector)
		in.LabelSelector.DeepCopyInto(out.LabelSelector)
	}
	if in.AnnotationSelector != nil {
		out.AnnotationSelector = make(map[string]string, len(in.AnnotationSelector))
		for key, val := range in.AnnotationSelector {
			out.AnnotationSelector[key] = val
		}
	}
}

func (in *ResourceSelector) DeepCopy() *ResourceSelector {
	if in == nil {
		return nil
	}
	out := new(ResourceSelector)
	in.DeepCopyInto(out)
	return out
}

func (in *Restore) DeepCopyInto(out *Restore) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *Restore) DeepCopy() *Restore {
	if in == nil {
		return nil
	}
	out := new(Restore)
	in.DeepCopyInto(out)
	return out
}

func (in *Restore) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *RestoreList) DeepCopyInto(out *RestoreList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		out.Items = make([]Restore, len(in.Items))
		for i := range in.Items {
			in.Items[i].DeepCopyInto(&out.Items[i])
		}
	}
}

func (in *RestoreList) DeepCopy() *RestoreList {
	if in == nil {
		return nil
	}
	out := new(RestoreList)
	in.DeepCopyInto(out)
	return out
}

func (in *RestoreList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *RestoreSpec) DeepCopyInto(out *RestoreSpec) {
	*out = *in
	if in.TargetClusterRef != nil {
		out.TargetClusterRef = new(corev1.LocalObjectReference)
		*out.TargetClusterRef = *in.TargetClusterRef
	}
	if in.NamespaceMapping != nil {
		out.NamespaceMapping = make(map[string]string, len(in.NamespaceMapping))
		for key, val := range in.NamespaceMapping {
			out.NamespaceMapping[key] = val
		}
	}
	if in.Timeout != nil {
		out.Timeout = new(metav1.Duration)
		*out.Timeout = *in.Timeout
	}
}

func (in *RestoreSpec) DeepCopy() *RestoreSpec {
	if in == nil {
		return nil
	}
	out := new(RestoreSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *RestoreStatus) DeepCopyInto(out *RestoreStatus) {
	*out = *in
	if in.Conditions != nil {
		out.Conditions = make([]metav1.Condition, len(in.Conditions))
		copy(out.Conditions, in.Conditions)
	}
	if in.StartedAt != nil {
		out.StartedAt = new(metav1.Time)
		*out.StartedAt = *in.StartedAt
	}
	if in.CompletedAt != nil {
		out.CompletedAt = new(metav1.Time)
		*out.CompletedAt = *in.CompletedAt
	}
}

func (in *RestoreStatus) DeepCopy() *RestoreStatus {
	if in == nil {
		return nil
	}
	out := new(RestoreStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *S3LocationSpec) DeepCopyInto(out *S3LocationSpec) {
	*out = *in
	if in.CABundle != nil {
		out.CABundle = make([]byte, len(in.CABundle))
		copy(out.CABundle, in.CABundle)
	}
}

func (in *S3LocationSpec) DeepCopy() *S3LocationSpec {
	if in == nil {
		return nil
	}
	out := new(S3LocationSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SnapshotSpec) DeepCopyInto(out *SnapshotSpec) {
	*out = *in
	if in.Enabled != nil {
		out.Enabled = new(bool)
		*out.Enabled = *in.Enabled
	}
	if in.PVCSelector != nil {
		out.PVCSelector = new(metav1.LabelSelector)
		in.PVCSelector.DeepCopyInto(out.PVCSelector)
	}
	if in.VolumeSnapshotClassName != nil {
		out.VolumeSnapshotClassName = new(string)
		*out.VolumeSnapshotClassName = *in.VolumeSnapshotClassName
	}
}

func (in *SnapshotSpec) DeepCopy() *SnapshotSpec {
	if in == nil {
		return nil
	}
	out := new(SnapshotSpec)
	in.DeepCopyInto(out)
	return out
}
